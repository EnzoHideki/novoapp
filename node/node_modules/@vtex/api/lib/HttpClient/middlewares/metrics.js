"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ramda_1 = require("ramda");
const utils_1 = require("../../utils");
const retry_1 = require("../../utils/retry");
const status_1 = require("../../utils/status");
const parseServerTiming = (serverTimingsHeaderValue) => ramda_1.compose(ramda_1.reduce((acc, rawHeader) => {
    const [name, durStr] = rawHeader.split(';');
    const [_, dur] = durStr ? durStr.split('=') : [null, null];
    const { hopNumber, source, target } = utils_1.parseTimingName(name);
    const formatted = utils_1.formatTimingName({
        hopNumber: Number.isNaN(hopNumber) ? null : hopNumber + 1,
        source,
        target,
    });
    if (dur && formatted) {
        acc.push([formatted, dur]);
    }
    return acc;
}, []), ramda_1.split(','), ramda_1.replace(/\s/g, ''))(serverTimingsHeaderValue);
exports.metricsMiddleware = ({ metrics, serverTiming, name }) => {
    const serverTimingStart = process.hrtime();
    const serverTimingLabel = utils_1.shrinkTimings(utils_1.formatTimingName({
        hopNumber: 0,
        source: process.env.VTEX_APP_NAME,
        target: name || 'unknown',
    }));
    return async (ctx, next) => {
        const start = process.hrtime();
        let status = 'unknown';
        try {
            await next();
            if (ctx.config.metric && ctx.response && ctx.response.status) {
                status = status_1.statusLabel(ctx.response.status);
            }
        }
        catch (err) {
            if (ctx.config.metric) {
                if (err.code === 'ECONNABORTED') {
                    status = 'aborted';
                }
                else if (err.response && err.response.data && err.response.data.code === retry_1.TIMEOUT_CODE) {
                    status = 'timeout';
                }
                else if (err.response && err.response.status) {
                    status = status_1.statusLabel(err.response.status);
                }
                else {
                    status = 'error';
                }
            }
            throw err;
        }
        finally {
            const end = process.hrtime(start);
            if (ctx.config.metric && metrics) {
                const label = `http-client-${status}-${ctx.config.metric}`;
                const extensions = {};
                if (ctx.cacheHit) {
                    Object.assign(extensions, ctx.cacheHit);
                }
                if (ctx.config['axios-retry']) {
                    const { retryCount } = ctx.config['axios-retry'];
                    if (retryCount && retryCount > 0) {
                        extensions[`retry-${retryCount}`] = 1;
                    }
                }
                metrics.batch(label, end, extensions);
            }
            if (serverTiming) {
                // Timings in the client's perspective
                const dur = utils_1.hrToMillis(process.hrtime(serverTimingStart));
                if (!serverTiming[serverTimingLabel] || Number(serverTiming[serverTimingLabel]) < dur) {
                    serverTiming[serverTimingLabel] = `${dur}`;
                }
                // Forward server timings
                const cacheHit = ctx.cacheHit && ramda_1.values(ctx.cacheHit).reduce((a, b) => a || b !== 0, false);
                const serverTimingsHeader = ramda_1.path(['response', 'headers', 'server-timing'], ctx);
                if (!cacheHit && serverTimingsHeader) {
                    const parsedServerTiming = parseServerTiming(serverTimingsHeader);
                    ramda_1.forEach(([timingsName, timingsDur]) => {
                        if (!serverTiming[timingsName] || Number(serverTiming[timingsName]) < Number(timingsDur)) {
                            serverTiming[timingsName] = timingsDur;
                        }
                    }, parsedServerTiming);
                }
            }
        }
    };
};
