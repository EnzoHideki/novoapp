"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const graphql_tools_1 = require("graphql-tools");
const messagesLoader_1 = require("../messagesLoader");
class Translatable extends graphql_tools_1.SchemaDirectiveVisitor {
    visitFieldDefinition(field) {
        const { resolve = graphql_1.defaultFieldResolver } = field;
        const { behavior = 'FULL' } = this.args;
        field.resolve = async (root, args, context, info) => {
            const { clients: { segment }, clients } = context;
            if (!context.loaders || !context.loaders.messages) {
                context.loaders = Object.assign({}, context.loaders, { messages: messagesLoader_1.messagesLoader(clients) });
            }
            const response = await resolve(root, args, context, info);
            // Messages only knows how to process non empty strings.
            if ((typeof response !== 'string' && typeof response !== 'object') || Array.isArray(response) || response == null) {
                return response;
            }
            const resObj = typeof response === 'string'
                ? {
                    content: response,
                    description: '',
                    from: undefined,
                    id: response,
                }
                : response;
            const { content, from, id } = resObj;
            const { cultureInfo: to } = await segment.getSegment();
            if (content == null && id == null) {
                throw new Error(`@translatable directive needs a content or id to translate, but received ${JSON.stringify(response)}`);
            }
            // If the message is already in the target locale, return the content.
            if (!to || from === to) {
                return content;
            }
            return context.loaders.messages.load(Object.assign({}, resObj, { behavior,
                from,
                to }));
        };
    }
}
exports.Translatable = Translatable;
