"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const status_1 = require("../../../utils/status");
const time_1 = require("../../../utils/time");
const unhandled_1 = require("../../../utils/unhandled");
const APP_ELAPSED_TIME_LOCATOR = time_1.shrinkTimings(time_1.formatTimingName({
    hopNumber: 0,
    source: process.env.VTEX_APP_NAME,
    target: '',
}));
const log = ({ vtex: { account, workspace, route: { id } }, path, method, status, req: { headers } }, millis) => 
// `${new Date().toISOString()}\t${account}/${workspace}:${id}\t${status}\t${method}\t${path}\t${millis}ms`
`${new Date().toISOString()}\t${account}/${workspace}:${id}\t${status}\t${method}\t${path}\t${millis}ms\t caller: ${JSON.stringify(headers['user-agent'])}`;
async function timings(ctx, next) {
    const start = process.hrtime();
    unhandled_1.updateLastLogger(ctx.clients.logger);
    // Errors will be caught by the next middleware so we don't have to catch.
    await next();
    const { status, vtex: { route: { id } } } = ctx;
    const end = process.hrtime(start);
    const millis = time_1.hrToMillis(end);
    console.log(log(ctx, millis));
    metrics.batch(`http-handler-${status_1.statusLabel(status)}-${id}`, end, { [status]: 1 });
    ctx.serverTiming[APP_ELAPSED_TIME_LOCATOR] = `${millis}`;
    ctx.set('Server-Timing', time_1.reduceTimings(ctx.serverTiming));
}
exports.timings = timings;
